PAGINACIÓN: estrategia de admin de memoria, basada en frames.
tamaño de marco #=4 (cantidad de celdas x frame) memoria de 16 celdas
cada proceso cargado en paginas, cada pagina asociada a un frames.
instruc/frame size = cant de paginas


-----------------------------------------------------------------------------------


PAGINACION BAJO DEMANDA
    bajo demanda
	si no tiene frame asignado, tirar interruption fallo de pagina
	cargar la pagina, si no hay frame libre, elegir victima y pasarla a disco


    interruption desde el MMU PageFoult(por param que page necesita)

    SWAP esta en MM

Tabla de paginas:
pid	pag	frame   Bit   Swap IdxSwap
1	0	 0       V     S       0
1	1	 -       I     N       -
2	0	 -       I     N       -
2	1	 2       V     N       -




loader -> page table

pageTable -> invalid -> PageFault(page)(del pid running)

pageFault -> cargar pagina en memoria, poner el frame en valido

swap -> in/out (frame)

swap
	pid + frame
	tiempo de carga (tick que fue cargado)


PageTable
	pid
	page
	frame
	valid/invalid (bit)
	swappage en que esta


	swap



LOADER: leer del disco la cantidad de instrucciones que entran en el frame
DISCO: get(name, page) = devuelve solo las intrucciones de esa page de ese program

PageTable: cuando se crea el pcb, los frames quedan en -1 indicando que no esta cargado en memory

MMU, si el frame es -1, tirar page fault(page) page como parametro

HANDLER PAGEFAULT:
primero ver si esta cargada en SWAP, sino, ir a buscar a disco

estrategia para seleccion de victima(dentro del MM):

FIFO: Cuando loader carga una pagina en un frame, guardar el tick para saber cual es el mas viejo
Elijo la mas vieja para mandar a SWAP. Cuando mando a SWAP me guardo el indice donde esta en el SWAP
SWAP: le digo guarda esta page y me devuelve el indice para ir a buscarla despues
Y pongo el frame -1 en la page table !!!

Cuando cargo de swap: actualizo el tick, borro flag de swap, cargo en memory, actualizo frame de pagetable, actualizo data de mmu

KILL: borrar pid de SWAP




